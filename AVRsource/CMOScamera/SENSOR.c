
/*************************************************************
;*                                                           *
;*       	   AVEO Technology Corp.                         *
;*         Copyright (c) 2004.All rights Reserved            *
;*                                                           *
;*       Project     :   USB2.0 PC Cammera                   *
;*       Device      :   Cheetah3 64PIN                      *
;*       Hareware    :   CN Demo                             *
;*       File        :   Sensor.C                            *
;*       Contents    :   Sensor Function                     *
;*       Sensor      :   OV7670                              *
;*       Written by  :   Rule Lu                             *
;*       Date        :   2006-11-24                          *
;*                                                           *
;*************************************************************/
#define  SENSOR_MODULE
#include <global.h>


#define SENSOR_WADDR      0x42	
#define SENSOR_RADDR      0x43	

#define EEPROM_WADDR	0xA0
#define EEPROM_RADDR	0xA1


//////////////////////	01	the following is sensor startup table
//code uchar SENSOR_StartUp_Table_YUV[]=
//{
//};

code uchar SENSOR_StartUp_Table_422_640_320_160_Common[]=
{
	0x0e, 0x61,
	0x0e, 0x61,
	0x0f, 0x4b,
	0x16, 0x02,
	0x1e, 0x37,//0x07,//0x01
	0x21, 0x02,
	0x22, 0x91,
	0x29, 0x07,
	0x33, 0x0b,//0x03
	0x35, 0x0b,
	0x37, 0x1d,
	0x38, 0x71,
	0x39, 0x2a,//0x00
	0x3c, 0x78,
	0x4d, 0x40,
	0x4e, 0x20,
	0x69, 0x00,//0x55
	0x6b, 0x4a,
	0x74, 0x19,
	0x8d, 0x4f,
	0x8e, 0x00,
	0x8f, 0x00,
	0x90, 0x00,
	0x91, 0x00,
	0x92, 0x00,//0x19,//0x66 ;insert dummy line
	0x96, 0x00,
	0x9a, 0x80,
	0xb0, 0x84,//0x8c
	0xb1, 0x0c,
	0xb2, 0x0e,
	0xb3, 0x82,
	0xb8, 0x0a,
	
//	0xbe,0x03, // change according to Jim's request
//	0xbf,0x03, // change according to Jim's request

	0x43, 0x14,
	0x43, 0x14,
	0x44, 0xf0,
	0x44, 0xf0,
	0x45, 0x34,
	0x46, 0x58,
	0x47, 0x28,
	0x48, 0x3a,
	0x59, 0x88,
	0x5a, 0x88,
	0x5b, 0x44,
	0x5c, 0x67,
	0x5d, 0x49,
	0x5e, 0x0e,
	0x64, 0x04,
	0x65, 0x20,
	0x66, 0x05,//for lens shading and color adjust
	0x94, 0x04,
	0x95, 0x08,
	0x6c, 0x0a,
	0x6d, 0x55,
	0x6e, 0x11,
	0x6f, 0x9f,//0x9e 0x9f,for advance AWB
	0x6a, 0x40,
	0x01, 0x40,
	0x02, 0x40,
	0x13, 0xe7,
	
	0x4f, 0x80,
	0x4f, 0x80,
	0x50, 0x80,
	0x51, 0x00,
	0x52, 0x22,
	0x53, 0x5e,
	0x54, 0x80,
	0x58, 0x9e,
	
	0x41, 0x08,
	0x41, 0x08,
	0x3f, 0x00,
	0x75, 0x05,
	0x76, 0xe1,
	0x4c, 0x00,
	0x77, 0x01,
	0x3d, 0xc2,
	0x4b, 0x09,
	0xc9, 0x60,
	0x41, 0x38,
	0x56, 0x45,//0x40,change according to Jim's request
	
	0x34, 0x11,
	0x34, 0x11,
	0x3b, 0xc2,//0xc0,//0xc2, 
	0xa4, 0x89,//0x88,
	0x96, 0x00,
	0x97, 0x30,
	0x98, 0x20,
	0x99, 0x30,
	0x9a, 0x84,
	0x9b, 0x29,
	0x9c, 0x03,
	0x9d, 0x4c,
	0x9e, 0x3f,
	0x78, 0x04,
	
	0x79, 0x01,
	0x79, 0x01,
	0xc8, 0xf0,
	0x79, 0x0f,
	0xc8, 0x00,
	0x79, 0x10,
	0xc8, 0x7e,
	0x79, 0x0a,
	0xc8, 0x80,
	0x79, 0x0b,
	0xc8, 0x01,
	0x79, 0x0c,
	0xc8, 0x0f,
	0x79, 0x0d,
	0xc8, 0x20,
	0x79, 0x09,
	0xc8, 0x80,
	0x79, 0x02,
	0xc8, 0xc0,
	0x79, 0x03,
	0xc8, 0x40,
	0x79, 0x05,
	0xc8, 0x30,
	0x79, 0x26,
	
//	0x42,0x00,	//变黑
};

code uchar SENSOR_StartUp_Table_422_640[]=
{
//; OV7673 setting, June 6, 2005
//; YCbCr, VGA
//; 15fps @ 24MHz input clock 
///0x12, 0x80,
///0x11, 0x00,	//0x03
	0x3a, 0x04,
	
	0x12, 0x00,
	0x17, 0x13,
	0x18, 0x01,
	0x32, 0xb6,
	0x19, 0x02,
	0x1a, 0x7a,//0x7a,
	0x03, 0x0e,//0x0a,
	0x0c, 0x00,
	0x3e, 0x00,
	0x70, 0x3a,
	0x71, 0x35,
	0x72, 0x11,
	0x73, 0xf0,
	0xa2, 0x02,
	
	0x7a, 0x20,	//get from i2c
	0x7b, 0x1c,
	0x7c, 0x28,
	0x7d, 0x3c,
	0x7e, 0x55,
	0x7f, 0x68,
	0x80, 0x76,
	0x81, 0x80,
	0x82, 0x88,
	0x83, 0x8f,
	0x84, 0x96,
	0x85, 0xa3,
	0x86, 0xaf,
	0x87, 0xc4,
	0x88, 0xd7,
	0x89, 0xe8,
	
	0x13, 0xe0,
	0x13, 0xe0,
	0x00, 0x00,
	0x10, 0x00,
	0x0d, 0x40,
	0x14, 0x28,//0x38 limit the max gain
	0xa5, 0x05,
	0xab, 0x07,
	0x24, 0x95,
	0x25, 0x33,
	0x26, 0xe3,
	0x55, 0x00,// 0xA0, // change according to Jim's request
	0x9f, 0xA0,
	0xa0, 0x90,
	0xa1, 0x03,//0x0b,
	0xa6, 0xdf,//0xd8,
	0xa7, 0xdf,//0xd8,
	0xa8, 0xf0,
	0xa9, 0x90,
	0xaa, 0x94,
	0x13, 0xe5,
    #if 0	
	0x0e, 0x61,
	0x0e, 0x61,
	0x0f, 0x4b,
	0x16, 0x02,
	0x1e, 0x37,//0x07,//0x01
	0x21, 0x02,
	0x22, 0x91,
	0x29, 0x07,
	0x33, 0x0b,//0x03
	0x35, 0x0b,
	0x37, 0x1d,
	0x38, 0x71,
	0x39, 0x2a,//0x00
	0x3c, 0x78,
	0x4d, 0x40,
	0x4e, 0x20,
	0x69, 0x00,//0x55
	0x6b, 0x4a,
	0x74, 0x19,
	0x8d, 0x4f,
	0x8e, 0x00,
	0x8f, 0x00,
	0x90, 0x00,
	0x91, 0x00,
	0x92, 0x00,//0x19,//0x66 ;insert dummy line
	0x96, 0x00,
	0x9a, 0x80,
	0xb0, 0x84,//0x8c
	0xb1, 0x0c,
	0xb2, 0x0e,
	0xb3, 0x82,
	0xb8, 0x0a,
	
//	0xbe,0x03, // change according to Jim's request
//	0xbf,0x03, // change according to Jim's request

	0x43, 0x14,
	0x43, 0x14,
	0x44, 0xf0,
	0x44, 0xf0,
	0x45, 0x34,
	0x46, 0x58,
	0x47, 0x28,
	0x48, 0x3a,
	0x59, 0x88,
	0x5a, 0x88,
	0x5b, 0x44,
	0x5c, 0x67,
	0x5d, 0x49,
	0x5e, 0x0e,
	0x64, 0x04,
	0x65, 0x20,
	0x66, 0x05,//for lens shading and color adjust
	0x94, 0x04,
	0x95, 0x08,
	0x6c, 0x0a,
	0x6d, 0x55,
	0x6e, 0x11,
	0x6f, 0x9f,//0x9e 0x9f,for advance AWB
	0x6a, 0x40,
	0x01, 0x40,
	0x02, 0x40,
	0x13, 0xe7,
	
	0x4f, 0x80,
	0x4f, 0x80,
	0x50, 0x80,
	0x51, 0x00,
	0x52, 0x22,
	0x53, 0x5e,
	0x54, 0x80,
	0x58, 0x9e,
	
	0x41, 0x08,
	0x41, 0x08,
	0x3f, 0x00,
	0x75, 0x05,
	0x76, 0xe1,
	0x4c, 0x00,
	0x77, 0x01,
	0x3d, 0xc2,
	0x4b, 0x09,
	0xc9, 0x60,
	0x41, 0x38,
	0x56, 0x45,//0x40,change according to Jim's request
	
	0x34, 0x11,
	0x34, 0x11,
	0x3b, 0xc2,//0xc0,//0xc2, 
	0xa4, 0x89,//0x88,
	0x96, 0x00,
	0x97, 0x30,
	0x98, 0x20,
	0x99, 0x30,
	0x9a, 0x84,
	0x9b, 0x29,
	0x9c, 0x03,
	0x9d, 0x4c,
	0x9e, 0x3f,
	0x78, 0x04,
	
	0x79, 0x01,
	0x79, 0x01,
	0xc8, 0xf0,
	0x79, 0x0f,
	0xc8, 0x00,
	0x79, 0x10,
	0xc8, 0x7e,
	0x79, 0x0a,
	0xc8, 0x80,
	0x79, 0x0b,
	0xc8, 0x01,
	0x79, 0x0c,
	0xc8, 0x0f,
	0x79, 0x0d,
	0xc8, 0x20,
	0x79, 0x09,
	0xc8, 0x80,
	0x79, 0x02,
	0xc8, 0xc0,
	0x79, 0x03,
	0xc8, 0x40,
	0x79, 0x05,
	0xc8, 0x30,
	0x79, 0x26,
	
//	0x42,0x00,	//变黑
    #endif

///////////////////////////////////////////////////////////////////
//the following is must for UVC function	//rule.lu note in 2006-11-23
//make sensor more lines output
	0x1a,0x7c,//V-stop
///////////////////////////////////////////////////////////////////

	0x1e, 0x37,//0x07image mirror and flip, rule lu modify in 2007-04-03 by andee mail need in 2007-04-03 10:38

	0x56, 0x4D,//rule lu add in 2007-05-08 by andee mail need in 2007-05-08 10:04
	0xAA, 0x14,//rule lu add in 2007-05-08 by andee mail need in 2007-05-08 10:04
};
code uchar SENSOR_StartUp_Table_422_320[]=
{
//; OV7670 setting, June 6, 2005
//; YCbCr, QVGA
//; 15fps @ 24MHz input clock
///0x12, 0x80,
///0x11, 0x00,	//0x03,
	0x3a, 0x04,
	
	0x12, 0x00,
	0x32, 0x80,
	0x17, 0x16,
	0x18, 0x04,
	0x19, 0x02,
	0x1a, 0x7b,//0x7a,
	0x03, 0x06,//0x0a,
	0x0c, 0x04,
	0x3e, 0x19,
	0x70, 0x3a,
	0x71, 0x35,
	0x72, 0x11,
	0x73, 0xf1,
	0xa2, 0x02,
	
	0x7a, 0x20,
	0x7b, 0x1c,
	0x7c, 0x28,
	0x7d, 0x3c,
	0x7e, 0x55,
	0x7f, 0x68,
	0x80, 0x76,
	0x81, 0x80,
	0x82, 0x88,
	0x83, 0x8f,
	0x84, 0x96,
	0x85, 0xa3,
	0x86, 0xaf,
	0x87, 0xc4,
	0x88, 0xd7,
	0x89, 0xe8,
	
	0x13, 0xe0,
	0x00, 0x00,
	0x10, 0x00,
	0x0d, 0x40,
	0x14, 0x28,//0x38, limit the max gain
	0xa5, 0x05,
	0xab, 0x07,
	0x24, 0x95,
	0x25, 0x33,
	0x26, 0xe3,
	0x9f, 0x78,
	0xa0, 0x68,
	0xa1, 0x03,//0x0b,
	0xa6, 0xdf,//0xd8,
	0xa7, 0xdf,//0xd8,
	0xa8, 0xf0,
	0xa9, 0x90,
	0xaa, 0x94,
	0x13, 0xe5,
	#if 0
	0x0e, 0x61,
	0x0f, 0x4b,
	0x16, 0x02,
	0x1e, 0x37,//0x07,
	0x21, 0x02,
	0x22, 0x91,
	0x29, 0x07,
	0x33, 0x0b,
	0x35, 0x0b,
	0x37, 0x1d,
	0x38, 0x71,
	0x39, 0x2a,
	0x3c, 0x78,
	0x4d, 0x40,
	0x4e, 0x20,
	0x69, 0x00,
	0x6b, 0x4a,
	0x74, 0x19,
	0x8d, 0x4f,
	0x8e, 0x00,
	0x8f, 0x00,
	0x90, 0x00,
	0x91, 0x00,
	0x92, 0x00,//0x19,//0x66
	0x96, 0x00,
	0x9a, 0x80,
	0xb0, 0x84,
	0xb1, 0x0c,
	0xb2, 0x0e,
	0xb3, 0x82,
	0xb8, 0x0a,
	
//	0xbe,0x03, // change according to Jim's request
//	0xbf,0x03, // change according to Jim's request

	0x43, 0x14,
	0x44, 0xf0,
	0x45, 0x34,
	0x46, 0x58,
	0x47, 0x28,
	0x48, 0x3a,
	0x59, 0x88,
	0x5a, 0x88,
	0x5b, 0x44,
	0x5c, 0x67,
	0x5d, 0x49,
	0x5e, 0x0e,
	0x64, 0x04,
	0x65, 0x20,
	0x66, 0x05,
	0x94, 0x04,
	0x95, 0x08,
	0x6c, 0x0a,
	0x6d, 0x55,
	0x6e, 0x11,
	0x6f, 0x9f,//0x9e for advance AWB
	0x6a, 0x40,
	0x01, 0x40,
	0x02, 0x40,
	0x13, 0xe7,
	
	0x4f, 0x80,
	0x50, 0x80,
	0x51, 0x00,
	0x52, 0x22,
	0x53, 0x5e,
	0x54, 0x80,
	0x58, 0x9e,
	
	0x41, 0x08,
	0x3f, 0x00,
	0x75, 0x05,
	0x76, 0xe1,
	0x4c, 0x00,
	0x77, 0x01,
	0x3d, 0xc2,	//0xc0,
	0x4b, 0x09,
	0xc9, 0x60,
	0x41, 0x38,
	0x56, 0x45,//0x40,  change according to Jim's request
	
	0x34, 0x11,
	0x3b, 0x02,//0x00,//0x02,
	0xa4, 0x89,//0x88,
	0x96, 0x00,
	0x97, 0x30,
	0x98, 0x20,
	0x99, 0x30,
	0x9a, 0x84,
	0x9b, 0x29,
	0x9c, 0x03,
	0x9d, 0x4c,
	0x9e, 0x3f,
	0x78, 0x04,
	
	0x79, 0x01,
	0xc8, 0xf0,
	0x79, 0x0f,
	0xc8, 0x00,
	0x79, 0x10,
	0xc8, 0x7e,
	0x79, 0x0a,
	0xc8, 0x80,
	0x79, 0x0b,
	0xc8, 0x01,
	0x79, 0x0c,
	0xc8, 0x0f,
	0x79, 0x0d,
	0xc8, 0x20,
	0x79, 0x09,
	0xc8, 0x80,
	0x79, 0x02,
	0xc8, 0xc0,
	0x79, 0x03,
	0xc8, 0x40,
	0x79, 0x05,
	0xc8, 0x30,
	0x79, 0x26,
	
	//88 f1 10
	//88 0f 1d
	//88 0f 1f
	
	0x3b, 0xC2,//0x82,//0xc0,//0xc2,	//night mode
	
//	0x42, 0x00,	
    #endif

///////////////////////////////////////////////////////////////////
//the following is must for UVC function	//rule.lu note in 2006-11-23
//make sensor more lines output
	0x19,0x02,//V-start
	0x03,0x0c,
	
	0x1a,0x7c,//V-stop
///////////////////////////////////////////////////////////////////

	0x1e, 0x37,//0x07 image mirror and flip, rule lu modify in 2007-04-03 by andee mail need in 2007-04-03 10:38

	0x56, 0x4D,//rule lu add in 2007-05-08 by andee mail need in 2007-05-08 10:04
	0xAA, 0x14,//rule lu add in 2007-05-08 by andee mail need in 2007-05-08 10:04
};
code uchar SENSOR_StartUp_Table_422_160[]=
{
//; OV7670 setting, June 6, 2005
//; YCbCr, QQVGA
//; 15fps @ 24MHz input clock
///0x12, 0x80,
///0x11, 0x00,	//0x03,
	0x3a, 0x04,
	
	0x12, 0x00,
	0x32, 0x64,//0xa4,
	0x17, 0x16,
	0x18, 0x04,
	0x19, 0x02,
	0x1a, 0x7b,		//0x7a,
	0x03, 0x06,		//0x0a,
	0x0c, 0x04,
	0x3e, 0x1a,
	0x70, 0x3a,
	0x71, 0x35,
	0x72, 0x22,
	0x73, 0xf2,
	0xa2, 0x02,
	
	0x7a, 0x20,
	0x7b, 0x1c,
	0x7c, 0x28,
	0x7d, 0x3c,
	0x7e, 0x5a,
	0x7f, 0x68,
	0x80, 0x76,
	0x81, 0x80,
	0x82, 0x88,
	0x83, 0x8f,
	0x84, 0x96,
	0x85, 0xa3,
	0x86, 0xaf,
	0x87, 0xc4,
	0x88, 0xd7,
	0x89, 0xe8,
	
	0x13, 0xe0,
	0x00, 0x00,
	0x10, 0x00,
	0x0d, 0x40,
	0x14, 0x28,//0x38, limit the max gain
	0xa5, 0x05,
	0xab, 0x07,
	0x24, 0x95,
	0x25, 0x33,
	0x26, 0xe3,
	0x9f, 0x78,
	0xa0, 0x68,
	0xa1, 0x03,//0x0b,
	0xa6, 0xdf,//0xd8,
	0xa7, 0xdf,//0xd8,
	0xa8, 0xf0,
	0xa9, 0x90,
	0xaa, 0x94,
	0x13, 0xe5,
	#if 0
	0x0e, 0x61,
	0x0f, 0x4b,
	0x16, 0x02,
	0x1e, 0x37,//0x07,
	0x21, 0x02,
	0x22, 0x91,
	0x29, 0x07,
	0x33, 0x0b,
	0x35, 0x0b,
	0x37, 0x1d,
	0x38, 0x71,
	0x39, 0x2a,
	0x3c, 0x78,
	0x4d, 0x40,
	0x4e, 0x20,
	0x69, 0x00,
	0x6b, 0x4a,
	0x74, 0x19,
	0x8d, 0x4f,
	0x8e, 0x00,
	0x8f, 0x00,
	0x90, 0x00,
	0x91, 0x00,
	0x92, 0x00,//0x19,//0x66
	0x96, 0x00,
	0x9a, 0x80,
	0xb0, 0x84,
	0xb1, 0x0c,
	0xb2, 0x0e,
	0xb3, 0x82,
	0xb8, 0x0a,

//	0xbe,0x03, // change according to Jim's request
//	0xbf,0x03, // change according to Jim's request

	0x43, 0x14,
	0x44, 0xf0,
	0x45, 0x34,
	0x46, 0x58,
	0x47, 0x28,
	0x48, 0x3a,
	0x59, 0x88,
	0x5a, 0x88,
	0x5b, 0x44,
	0x5c, 0x67,
	0x5d, 0x49,
	0x5e, 0x0e,
	0x64, 0x04,
	0x65, 0x20,
	0x66, 0x05,
	0x94, 0x04,
	0x95, 0x08,
	0x6c, 0x0a,
	0x6d, 0x55,
	0x6e, 0x11,
	0x6f, 0x9f,//0x9e for advance AWB
	0x6a, 0x40,
	0x01, 0x40,
	0x02, 0x40,
	0x13, 0xe7,
	
	0x4f, 0x80,
	0x50, 0x80,
	0x51, 0x00,
	0x52, 0x22,
	0x53, 0x5e,
	0x54, 0x80,
	0x58, 0x9e,
	
	0x41, 0x08,
	0x3f, 0x00,
	0x75, 0x05,
	0x76, 0xe1,
	0x4c, 0x00,
	0x77, 0x01,
	0x3d, 0xc2,	//0xc1,
	0x4b, 0x09,
	0xc9, 0x60,
	0x41, 0x38,
	0x56, 0x45,//0x40,  change according to Jim's request
	
	0x34, 0x11,
	0x3b, 0xC2,//0xc0,//0xc2,	//disable night mode
	0xa4, 0x89,//0x88,
	0x96, 0x00,
	0x97, 0x30,
	0x98, 0x20,
	0x99, 0x30,
	0x9a, 0x84,
	0x9b, 0x29,
	0x9c, 0x03,
	0x9d, 0x4c,
	0x9e, 0x3f,
	0x78, 0x04,
	
	0x79, 0x01,
	0xc8, 0xf0,
	0x79, 0x0f,
	0xc8, 0x00,
	0x79, 0x10,
	0xc8, 0x7e,
	0x79, 0x0a,
	0xc8, 0x80,
	0x79, 0x0b,
	0xc8, 0x01,
	0x79, 0x0c,
	0xc8, 0x0f,
	0x79, 0x0d,
	0xc8, 0x20,
	0x79, 0x09,
	0xc8, 0x80,
	0x79, 0x02,
	0xc8, 0xc0,
	0x79, 0x03,
	0xc8, 0x40,
	0x79, 0x05,
	0xc8, 0x30,
	0x79, 0x26,
	
	//88 f1 10
	//88 0f 1d
	//88 0f 1f
	
//	0x42,0x00,	//变黑
    #endif
///////////////////////////////////////////////////////////////////
//the following is must for UVC function	//rule.lu note in 2006-11-23
//make sensor more lines output
	0x19,0x00,//V-start
	0x03,0x0e,
	
	0x1a,0x7c,//V-stop
///////////////////////////////////////////////////////////////////

	0x1e, 0x37,//0x07image mirror and flip, rule lu modify in 2007-04-03 by andee mail need in 2007-04-03 10:38

	0x56, 0x4D,//rule lu add in 2007-05-08 by andee mail need in 2007-05-08 10:04
	0xAA, 0x14,//rule lu add in 2007-05-08 by andee mail need in 2007-05-08 10:04
};

code uchar SENSOR_StartUp_Table_422_352_176_Common[]=
{
		0x7a, 0x20,
		0x7b, 0x1c,
		0x7c, 0x28,
		0x7d, 0x3c,
		0x7e, 0x5a,
		0x7f, 0x68,
		0x80, 0x76,
		0x81, 0x80,
		0x82, 0x88,
		0x83, 0x8f,
		0x84, 0x96,
		0x85, 0xa3,
		0x86, 0xaf,
		0x87, 0xc4,
		0x88, 0xd7,
		0x89, 0xe8,
		////////
		0x13, 0xe0,
		0x00, 0x00,
		0x10, 0x00,
		0x0d, 0x40,
		0x14, 0x28,//0x38 limit the max gain
		0xa5, 0x05,
		0xab, 0x07,
		0x24, 0x95,
		0x25, 0x33,
		0x26, 0xe3,
		0x9f, 0x78,
		0xa0, 0x68,
		0xa1, 0x0b,
		0xa6, 0xd8,
		0xa7, 0xd8,
		0xa8, 0xf0,
		0xa9, 0x90,
		0xaa, 0x94,
		0x13, 0xe5,
		////////
		0x0e, 0x61,
		0x0f, 0x4b,
		0x16, 0x02,
		0x21, 0x02,
		0x22, 0x91,
		0x29, 0x07,
		0x33, 0x03,
		0x35, 0x0b,
		0x37, 0x1c,
		0x38, 0x71,
		0x3c, 0x78,
		0x4d, 0x40,
		0x4e, 0x20,
		0x69, 0x55,
		0x6b, 0x4a,
		0x74, 0x19,
		0x8d, 0x4f,
		0x8e, 0x00,
		0x8f, 0x00,
		0x90, 0x00,
		0x91, 0x00,
		0x96, 0x00,
		0x9a, 0x80,
		0xb0, 0x8c,
		0xb1, 0x0c,
		0xb2, 0x0e,
		0xb3, 0x82,
		0xb8, 0x0a,
		////////
		0x43, 0x14,
		0x44, 0xf0,
		0x45, 0x34,
		0x46, 0x58,
		0x47, 0x28,
		0x48, 0x3a,
		0x59, 0x88,
		0x5a, 0x88,
		0x5b, 0x44,
		0x5c, 0x67,
		0x5d, 0x49,
		0x5e, 0x0e,
		0x6c, 0x0a,
		0x6d, 0x55,
		0x6e, 0x11,
		0x6f, 0x9f, //9e for advance AWB
		0x6a, 0x40,
		0x01, 0x40,
		0x02, 0x40,
		0x13, 0xe7,
		//////////
		0x4f, 0x80,
		0x50, 0x80,
		0x51, 0x00,
		0x52, 0x22,
		0x53, 0x5e,
		0x54, 0x80,
		0x58, 0x9e,
		//////////
		0x41, 0x08,
		0x3f, 0x00,
		0x75, 0x05,
		0x76, 0x61,
		0x4c, 0x00,
		0x77, 0x01,
		0x3d, 0xc2,
		0x4b, 0x09,
		0xc9, 0x60,
		0x41, 0x38,
		0x56, 0x40,
		//////////
		0x34, 0x11,
		0x3b, 0x02,
		0xa4, 0x89,//0x88,
		0x96, 0x00,
		0x97, 0x30,
		0x98, 0x20,
		0x99, 0x20,
		0x9a, 0x84,
		0x9b, 0x29,
		0x9c, 0x03,
		0x9d, 0x4c,
		0x9e, 0x3f,
		0x78, 0x04,
		//////////
		0x79, 0x01,
		0xc8, 0xf0,
		0x79, 0x0f,
		0xc8, 0x20,
		0x79, 0x10,
		0xc8, 0x7e,
		0x79, 0x0b,
		0xc8, 0x01,
		0x79, 0x0c,
		0xc8, 0x07,
		0x79, 0x0d,
		0xc8, 0x20,
		0x79, 0x09,
		0xc8, 0x80,
		0x79, 0x02,
		0xc8, 0xc0,
		0x79, 0x03,
		0xc8, 0x40,
		0x79, 0x05,
		0xc8, 0x30,
		0x79, 0x26,
		//////////
//		88 f1 10
//		88 0f 1d
//		88 0f 1f
        0x3b, 0xC2, //0x02
///////////////////////////////////////////////
	    0x19,0x02,//V-start
	    0x03,0x0c,
	
	    0x1a,0x7c,//V-stop
////////////////////////////////////////////////
       	0x1e, 0x37,//0x07image mirror and flip, rule lu modify in 2007-04-03 by andee mail need in 2007-04-03 10:38
};

code uchar SENSOR_StartUp_Table_422_352[]=
{
//OV7670 setting, June 6, 2005
//YCbCr, CIF
//15fps @ 24MHz input clock 
//
		0x12, 0x80,
		//////////
		0x11, 0x00,//0x03
		0x11, 0x00,//0x03
		0x3a, 0x04,
		0x12, 0x00,
		0x17, 0x15,//0x15
		0x18, 0x0b,//0x0b
		0x32, 0xb6,//0xb6
		0x19, 0x03,
		0x1a, 0x7b,
		0x03, 0x0a,
		0x0c, 0x08,
		0x3e, 0x11,
		0x70, 0x3a,
		0x71, 0x35,
		0x72, 0x11,
		0x73, 0xf1,
		0xa2, 0x02,
#if 0
		//////////
		0x7a, 0x20,
		0x7b, 0x1c,
		0x7c, 0x28,
		0x7d, 0x3c,
		0x7e, 0x5a,
		0x7f, 0x68,
		0x80, 0x76,
		0x81, 0x80,
		0x82, 0x88,
		0x83, 0x8f,
		0x84, 0x96,
		0x85, 0xa3,
		0x86, 0xaf,
		0x87, 0xc4,
		0x88, 0xd7,
		0x89, 0xe8,
		////////
		0x13, 0xe0,
		0x00, 0x00,
		0x10, 0x00,
		0x0d, 0x40,
		0x14, 0x28,//0x38 limit the max gain
		0xa5, 0x05,
		0xab, 0x07,
		0x24, 0x95,
		0x25, 0x33,
		0x26, 0xe3,
		0x9f, 0x78,
		0xa0, 0x68,
		0xa1, 0x0b,
		0xa6, 0xd8,
		0xa7, 0xd8,
		0xa8, 0xf0,
		0xa9, 0x90,
		0xaa, 0x94,
		0x13, 0xe5,
		////////
		0x0e, 0x61,
		0x0f, 0x4b,
		0x16, 0x02,
		0x21, 0x02,
		0x22, 0x91,
		0x29, 0x07,
		0x33, 0x03,
		0x35, 0x0b,
		0x37, 0x1c,
		0x38, 0x71,
		0x3c, 0x78,
		0x4d, 0x40,
		0x4e, 0x20,
		0x69, 0x55,
		0x6b, 0x4a,
		0x74, 0x19,
		0x8d, 0x4f,
		0x8e, 0x00,
		0x8f, 0x00,
		0x90, 0x00,
		0x91, 0x00,
		0x96, 0x00,
		0x9a, 0x80,
		0xb0, 0x8c,
		0xb1, 0x0c,
		0xb2, 0x0e,
		0xb3, 0x82,
		0xb8, 0x0a,
		////////
		0x43, 0x14,
		0x44, 0xf0,
		0x45, 0x34,
		0x46, 0x58,
		0x47, 0x28,
		0x48, 0x3a,
		0x59, 0x88,
		0x5a, 0x88,
		0x5b, 0x44,
		0x5c, 0x67,
		0x5d, 0x49,
		0x5e, 0x0e,
		0x6c, 0x0a,
		0x6d, 0x55,
		0x6e, 0x11,
		0x6f, 0x9f, //9e for advance AWB
		0x6a, 0x40,
		0x01, 0x40,
		0x02, 0x40,
		0x13, 0xe7,
		//////////
		0x4f, 0x80,
		0x50, 0x80,
		0x51, 0x00,
		0x52, 0x22,
		0x53, 0x5e,
		0x54, 0x80,
		0x58, 0x9e,
		//////////
		0x41, 0x08,
		0x3f, 0x00,
		0x75, 0x05,
		0x76, 0x61,
		0x4c, 0x00,
		0x77, 0x01,
		0x3d, 0xc2,
		0x4b, 0x09,
		0xc9, 0x60,
		0x41, 0x38,
		0x56, 0x40,
		//////////
		0x34, 0x11,
		0x3b, 0x02,
		0xa4, 0x89,//0x88,
		0x96, 0x00,
		0x97, 0x30,
		0x98, 0x20,
		0x99, 0x20,
		0x9a, 0x84,
		0x9b, 0x29,
		0x9c, 0x03,
		0x9d, 0x4c,
		0x9e, 0x3f,
		0x78, 0x04,
		//////////
		0x79, 0x01,
		0xc8, 0xf0,
		0x79, 0x0f,
		0xc8, 0x20,
		0x79, 0x10,
		0xc8, 0x7e,
		0x79, 0x0b,
		0xc8, 0x01,
		0x79, 0x0c,
		0xc8, 0x07,
		0x79, 0x0d,
		0xc8, 0x20,
		0x79, 0x09,
		0xc8, 0x80,
		0x79, 0x02,
		0xc8, 0xc0,
		0x79, 0x03,
		0xc8, 0x40,
		0x79, 0x05,
		0xc8, 0x30,
		0x79, 0x26,
		//////////
//		88 f1 10
//		88 0f 1d
//		88 0f 1f
///////////////////////////////////////////////
	    0x19,0x02,//V-start
	    0x03,0x0c,
	
	    0x1a,0x7c,//V-stop
////////////////////////////////////////////////
       	0x1e, 0x37,//0x07 image mirror and flip, rule lu modify in 2007-04-03 by andee mail need in 2007-04-03 10:38
#endif
};

code uchar SENSOR_StartUp_Table_422_176[]=
{
		// OV7670 setting, June 6, 2005
		//YCbCr, QCIF
		//15fps @ 24MHz input clock 
		/////////
		0x12, 0x80,
		/////////
		0x11, 0x00,//0x03
		0x11, 0x00,//0x03
		0x3a, 0x04,
		0x12, 0x00,
		0x17, 0x39,
		0x18, 0x03,
		0x32, 0x92,
		0x19, 0x03,
		0x1a, 0x7b,
		0x03, 0x0a,
		0x0c, 0x0c,
		0x3e, 0x11,
		0x70, 0x3a,
		0x71, 0x35,
		0x72, 0x11,
		0x73, 0xf1,
		0xa2, 0x52,
		////////////
#if 0
		0x7a, 0x20,
		0x7b, 0x1c,
		0x7c, 0x28,
		0x7d, 0x3c,
		0x7e, 0x5a,
		0x7f, 0x68,
		0x80, 0x76,
		0x81, 0x80,
		0x82, 0x88,
		0x83, 0x8f,
		0x84, 0x96,
		0x85, 0xa3,
		0x86, 0xaf,
		0x87, 0xc4,
		0x88, 0xd7,
		0x89, 0xe8,
		//////////////
		0x13, 0xe0,
		0x00, 0x00,
		0x10, 0x00,
		0x0d, 0x40,
		0x14, 0x28,//0x38 limit the max gain
		0xa5, 0x05,
		0xab, 0x07,
		0x24, 0x95,
		0x25, 0x33,
		0x26, 0xe3,
		0x9f, 0x78,
		0xa0, 0x68,
		0xa1, 0x0b,
		0xa6, 0xd8,
		0xa7, 0xd8,
		0xa8, 0xf0,
		0xa9, 0x90,
		0xaa, 0x94,
		0x13, 0xe5,
		////////////
		0x0e, 0x61,
		0x0f, 0x4b,
		0x16, 0x02,
		0x21, 0x02,
		0x22, 0x91,
		0x29, 0x07,
		0x33, 0x03,
		0x35, 0x0b,
		0x37, 0x1c,
		0x38, 0x71,
		0x3c, 0x78,
		0x4d, 0x40,
		0x4e, 0x20,
		0x69, 0x55,
		0x6b, 0x4a,
		0x74, 0x19,
		0x8d, 0x4f,
		0x8e, 0x00,
		0x8f, 0x00,
		0x90, 0x00,
		0x91, 0x00,
		0x96, 0x00,
		0x9a, 0x80,
		0xb0, 0x8c,
		0xb1, 0x0c,
		0xb2, 0x0e,
		0xb3, 0x82,
		0xb8, 0x0a,
		//////////
		0x43, 0x14,
		0x44, 0xf0,
		0x45, 0x34,
		0x46, 0x58,
		0x47, 0x28,
		0x48, 0x3a,
		0x59, 0x88,
		0x5a, 0x88,
		0x5b, 0x44,
		0x5c, 0x67,
		0x5d, 0x49,
		0x5e, 0x0e,
		0x6c, 0x0a,
		0x6d, 0x55,
		0x6e, 0x11,
		0x6f, 0x9f, //9e for Advance AWB
		0x6a, 0x40,
		0x01, 0x40,
		0x02, 0x40,
		0x13, 0xe7,
		///////////////
		0x4f, 0x80,
		0x50, 0x80,
		0x51, 0x00,
		0x52, 0x22,
		0x53, 0x5e,
		0x54, 0x80,
		0x58, 0x9e,
		////////////
		0x41, 0x08,
		0x3f, 0x00,
		0x75, 0x05,
		0x76, 0x61,
		0x4c, 0x00,
		0x77, 0x01,
		0x3d, 0xc2,
		0x4b, 0x09,
		0xc9, 0x60,
		0x41, 0x38,
		0x56, 0x40,
		//////////
		0x34, 0x11,
		0x3b, 0x02,
		0xa4, 0x89,//0x88,
		0x96, 0x00,
		0x97, 0x30,
		0x98, 0x20,
		0x99, 0x20,
		0x9a, 0x84,
		0x9b, 0x29,
		0x9c, 0x03,
		0x9d, 0x4c,
		0x9e, 0x3f,
		0x78, 0x04,
		//////////
		0x79, 0x01,
		0xc8, 0xf0,
		0x79, 0x0f,
		0xc8, 0x20,
		0x79, 0x10,
		0xc8, 0x7e,
		0x79, 0x0b,
		0xc8, 0x01,
		0x79, 0x0c,
		0xc8, 0x07,
		0x79, 0x0d,
		0xc8, 0x20,
		0x79, 0x09,
		0xc8, 0x80,
		0x79, 0x02,
		0xc8, 0xc0,
		0x79, 0x03,
		0xc8, 0x40,
		0x79, 0x05,
		0xc8, 0x30,
		0x79, 0x26,
		///////////////
//		88 f1 10
//		88 0f 1d
//		88 0f 1f
//////////////////////////////////
       	0x19,0x02,//V-start
    	0x03,0x0c,
	
	    0x1a,0x7c,//V-stop
/////////////////////////////////
       	0x1e, 0x37,//0x07 image mirror and flip, rule lu modify in 2007-04-03 by andee mail need in 2007-04-03 10:38   
#endif
};
#if 0
code uchar SENSOR_StartUp_Table_Gamma[]=
{
	0x7a, 0x20,	//get from i2c
	0x7b, 0x1c,
	0x7c, 0x28,
	0x7d, 0x3c,
	0x7e, 0x55,
	0x7f, 0x68,
	0x80, 0x76,
	0x81, 0x80,
	0x82, 0x88,
	0x83, 0x8f,
	0x84, 0x96,
	0x85, 0xa3,
	0x86, 0xaf,
	0x87, 0xc4,
	0x88, 0xd7,
	0x89, 0xe8,
};
#endif

uchar Sensor_Read_Register(uchar ucAddrR)
{
	uchar ucData;   

	Sensor_I2C_CLK_Configurate_();
	
	Sensor_I2C_Start_();
	Sensor_I2C_Send_Byte_(SENSOR_WADDR);       // Sensor ID + write bit

	Sensor_I2C_Wait_Ack_();
	Sensor_I2C_Send_Byte_(ucAddrR);
	Sensor_I2C_Wait_Ack_();
	Sensor_I2C_Stop_();

	Sensor_I2C_Start_();
	Sensor_I2C_Send_Byte_(SENSOR_RADDR);       // Sensor ID + read bit
	Sensor_I2C_Wait_Ack_();
	ucData = Sensor_I2C_Recv_Byte_();
	Sensor_I2C_Send_NAck_();
	Sensor_I2C_Stop_();

	I2CDelay_1us(200);
	
	return ucData;
}

void Sensor_Write_Register(uchar ucAddrR, uchar ucDataR) 
{
	Sensor_I2C_CLK_Configurate_();
	
	Sensor_I2C_Start_();
	Sensor_I2C_Send_Byte_(SENSOR_WADDR);    // Sensor ID + write bit
	Sensor_I2C_Wait_Ack_();
	Sensor_I2C_Send_Byte_(ucAddrR);
	Sensor_I2C_Wait_Ack_();
	Sensor_I2C_Send_Byte_(ucDataR);
	Sensor_I2C_Wait_Ack_();
	Sensor_I2C_Stop_();

	I2CDelay_1us(200);

	return;
}

void SensorRGF_Set_Loop(uint ucCount, uchar code * ucTable) reentrant
{
	/*xdata*/ uint ucI;
	for(ucI=0;ucI<ucCount;ucI++)
	{
		Sensor_Write_Register(ucTable[2*ucI],ucTable[2*ucI+1]);    
	}
}

//uchar	nightmode = 0; //1:night mode(initial default), 0:disable night mode
//uchar uSaturation = 3;
//uchar ucAE_ET_L,ucAE_ET_H,ucAE_Gain;


void Init_Sensor(void) 
{
	//1. Power control
	SENSORPOWERON;
	Delay_1ms(30);	//(30);		

	//2. Sensor standby operation
	SENSORSTANDBYOFF;
	Delay_1ms(10);	//(30);		
    
    //3. Sensor reset operation
	SensorReset();

	//4. Set main clock 
	CheetahR[0x1D] &= 0x03;	 	//Clear bit 3,2
	CheetahR[0x1C] &= 0x0f;
	if(USBSpeed==HighSpeed)
	{
//		if((uixVLength >> 12) == Output_YUV422)			// USB 2.0 YUV
		{
		//	CheetahR[0x1D] |= 0x04;
		//	CheetahR[0x1C] |= 0x30;//0x30;//0x60;	//12MHz	
		    CheetahR[0x1D] |= 0x04;
			CheetahR[0x1C] |= 0x30;//0x30;//0x60;	//12MHz	
			CheetahR[0x1C] |= 0x80;	//Enable MCLK 
		    Delay_1ms(10);
			Sensor_Write_Register(0x11,0x00);	//sensor div=1
			Sensor_Write_Register(0x11,0x00);	//sensor div=1
		}
	}
	else
	{
//		if((uixVLength >> 12) == Output_YUV422)			// USB 1.1 YUV
		{
//			if(uixHLength == 640)		{CheetahR[0x1D] |= 0x0C;CheetahR[0x1C] |= 0x70;}//printf("USB1.1  02.5M mclk\n");}
//	    	else if(uixHLength == 320)	{CheetahR[0x1D] |= 0x0C;CheetahR[0x1C] |= 0x20;}//printf("USB1.1  10.0M mclk\n");}
//	    	else if(uixHLength == 160)	{CheetahR[0x1D] |= 0x04;CheetahR[0x1C] |= 0x20;}//printf("USB1.1  40.0M mclk\n");}
//			CheetahR[0x1C] |= 0x80;	//Enable MCLK 
//		    Delay_1ms(10);
//			Sensor_Write_Register(0x11,0x04);	//sensor div=5
//			Sensor_Write_Register(0x11,0x04);	//sensor div=5
			CheetahR[0x1D] |= 0x0C;
			CheetahR[0x1C] |= 0x60;//printf("USB1.1  03.0M mclk\n");
			CheetahR[0x1C] |= 0x80;	//Enable MCLK 
		} 

	    Delay_1ms(10);
		if(uixHLength == 640)		{Sensor_Write_Register(0x11,0x07);Sensor_Write_Register(0x11,0x07);}	//sensor div=8
    	else if(uixHLength == 320)	{Sensor_Write_Register(0x11,0x01);Sensor_Write_Register(0x11,0x01);}	//sensor div=2
    	else if(uixHLength == 160)	{Sensor_Write_Register(0x11,0x80);Sensor_Write_Register(0x11,0x80);}	//sensor mul=2
	}

//	nightmode = 1;

//	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table)/2,SENSOR_StartUp_Table);
//	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_Modify)/2,SENSOR_StartUp_Table_Modify);
//	printf("Initial Sensor: End\n");
}

void Set_160x120_Frame_422(void)
{
    SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_160)/2,SENSOR_StartUp_Table_422_160);
	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_640_320_160_Common)/2,SENSOR_StartUp_Table_422_640_320_160_Common);
//	Set_Sensor_LightEnvironment(0x02);
}
void Set_320x240_Frame_422(void)
{
    SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_320)/2,SENSOR_StartUp_Table_422_320);
	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_640_320_160_Common)/2,SENSOR_StartUp_Table_422_640_320_160_Common);
//	Set_Sensor_LightEnvironment(0x02);
	if(USBSpeed!=HighSpeed)	Sensor_Write_Register(0x32, 0x82);
}
void Set_640x480_Frame_422(void)
{ 
    SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_640)/2,SENSOR_StartUp_Table_422_640);
	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_640_320_160_Common)/2,SENSOR_StartUp_Table_422_640_320_160_Common);
//	Set_Sensor_LightEnvironment(0x02);
//	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_Gamma)/2,SENSOR_StartUp_Table_Gamma);	
}

void Set_352x288_Frame_422(void)
{
	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_352)/2,SENSOR_StartUp_Table_422_352);
    SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_352_176_Common)/2,SENSOR_StartUp_Table_422_352_176_Common);
//	Set_Sensor_LightEnvironment(0x02);
//	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_Gamma)/2,SENSOR_StartUp_Table_Gamma);	
}

void Set_176x144_Frame_422(void)
{
	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_176)/2,SENSOR_StartUp_Table_422_176);
    SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_422_352_176_Common)/2,SENSOR_StartUp_Table_422_352_176_Common);
//	Set_Sensor_LightEnvironment(0x02);
//	SensorRGF_Set_Loop(sizeof(SENSOR_StartUp_Table_Gamma)/2,SENSOR_StartUp_Table_Gamma);	
}

#if 1
code uchar Dummy_Pixel[]=
{
//  outdoor 50Hz   60Hz
	0x00,  0x00,   0x03,        //usb 2.0 YUV    640, 320, 160, 352, 176
};

code uchar Banding_Filter[]=
{
//  outdoor 50Hz   60Hz
    0x78,  0x99,   0x7f,        //usb 2.0 YUV    640, 320, 160, 352, 176
};

void Set_Sensor_LightEnvironment(void)
{
	uchar ucI;
	
	ucI=0;		
	if(ucxUVC_PU_Power_Frequency_Param == 0x00)				//outdoor, off
	{
//		AutoProperty1Statue &= 0xfd;

//		if((uixVLength >> 12) == Output_YUV422)		
		ucI = 0x00;

		Sensor_Write_Register(0xa1, 0x03);
		Sensor_Write_Register(0xa6, 0xdf);
		Sensor_Write_Register(0xa7, 0xdf);

	}
	else if(ucxUVC_PU_Power_Frequency_Param == 0x01)			//50Hz
	{
//		AutoProperty1Statue |= 0x02;
//		AutoProperty1Statue &= 0xfe;
//		if(AutoProperty2Statue&0x01==0x00)	//auto exposure time, it can anti-flicker at auto
		{
//			if((uixVLength >> 12) == Output_YUV422)
			ucI = 0x01;
		}

		Sensor_Write_Register(0xa1, 0x0b);
		Sensor_Write_Register(0xa6, 0xd8);
		Sensor_Write_Register(0xa7, 0xd8);
	}
	else if(ucxUVC_PU_Power_Frequency_Param == 0x02)			//60Hz
	{
//		AutoProperty1Statue |= 0x02;
//		AutoProperty1Statue |= 0x01;
//		if(AutoProperty2Statue&0x01==0x00)	//auto exposure time, it can anti-flicker at auto
		{
//			if((uixVLength >> 12) == Output_YUV422)
			ucI = 0x02;
		}
		Sensor_Write_Register(0xa1, 0x03);//0x0b);
		Sensor_Write_Register(0xa6, 0xdf);//0xd8);
		Sensor_Write_Register(0xa7, 0xdf);//0xd8);
	}
	Sensor_Write_Register(0x2b, Dummy_Pixel[ucI]);//0x03);			//dummy pixel, 0x2a[7:4]+0x2b						
	Sensor_Write_Register(0x9d, Banding_Filter[ucI]);				//50Hz setting value, 0x9d
	Sensor_Write_Register(0x9e, Banding_Filter[ucI]);				//60Hz setting value, 0x9e

	if(ucxUVC_PU_Power_Frequency_Param == 0x00)//outdoor
	{
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf5));
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x02));
		Sensor_Write_Register(0xa5, 0x05);
		Sensor_Write_Register(0xab, 0x07);
	}
	if(ucxUVC_PU_Power_Frequency_Param == 0x01)//50hz
	{
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf5));
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x08));
		Sensor_Write_Register(0xa5, 0x02);
		Sensor_Write_Register(0xab, 0x03);
	}
	if(ucxUVC_PU_Power_Frequency_Param == 0x02)//60hz
	{
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf5));
		Sensor_Write_Register(0xa5, 0x05);
		Sensor_Write_Register(0xab, 0x07);
	}
/*
	Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0x7f));	// disable night mode
	Sensor_Write_Register(0x2d, 0x00);	// clear 0x2d,0x2e
	Sensor_Write_Register(0x2e, 0x00);
*/
}
#else
code uchar Dummy_Pixel[]=
{
//       00Hz   50Hz    60Hz
//       low    low     low
         0x00,  0x00,   0x00,        //usb 2.0 YUV    640, 320, 160
         0x01,  0x3b,   0x9b,        //usb 2.0 RAW    640, 320, 160
         0x60,  0x6d,   0x54,        //usb 1.1 YUV    640
         0x19,  0x19,   0x19,        //usb 1.1 YUV    320, 352// setting 2.5MHz
         0x02,  0x02,   0x02,        //usb 1.1 YUV    160, 176// setting 5MHz
         0x20,  0x20,   0x32,        //usb 1.1 RAW    640
         0x10,  0x4c,   0x4c,        //usb 1.1 RAW    320
         0x00,  0x00,   0x00,        //usb 1.1 RAW    160
};

code uchar Banding_Filter[]=
{
//       00Hz   50Hz    60Hz
//       low    low     low
         0x78,  0x99,   0x7f,        //usb 2.0 YUV    640, 320, 160
         0x78,  0xb2,   0x85,        //usb 2.0 RAW    640, 320, 160
         0x1a,  0x1c,   0x18,        //usb 1.1 YUV    640
         0x1d,  0x1f,   0x1a,         //usb 1.1 YUV   320, 352 // setting 2.5MHz
   //    0x50,  0x5f,   0x4f,         //usb 1.1 YUV   160, 176 // setting 3.75MHz
         0x38,  0x3E,   0x33,         //usb 1.1 YUV   160, 176 // setting 5MHz
         0x2c,  0x30,   0x27,        //usb 1.1 RAW    640
         0x62,  0x73,   0x60,        //usb 1.1 RAW    320
         0x5d,  0x66,   0x55,        //usb 1.1 RAW    160
};

void Set_Sensor_LightEnvironment(void)
{
	uchar ucI;
	ucI=0;		//
	if(ucxUVC_PU_Power_Frequency_Param == 0x00)				//outdoor, off
	{
//		AutoProperty1Statue &= 0xfd;

//		if(AutoProperty2Statue&0x01==0x00)	//auto exposure time, it can anti-flicker at auto
		{
			if(USBSpeed==HighSpeed)	
			{
			/*	if((uixVLength >> 12) == Output_YUV422)			ucI = 0x00;
				else if((uixVLength >> 12) == Output_RAWDATA)	ucI = 0x03; */
				ucI = 0x00;
			}
			else 
			{
				if((uixVLength >> 12) == Output_YUV422)
				{
					if(uixHLength == 640)						            ucI = 0x06;	
					else if((uixHLength == 320)||(uixHLength == 352)) 		ucI = 0x09;	
					else if((uixHLength == 160)||(uixHLength == 176)) 		ucI = 0x0c;	
				}
			/*	else if((uixVLength >> 12) == Output_RAWDATA)
				{
					if(uixHLength == 640)						ucI = 0x0f;	
					else if(uixHLength == 320) 					ucI = 0x12;	
					else if(uixHLength == 160) 					ucI = 0x15;	
				} */
			}
		}
	
		Sensor_Write_Register(0xa1, 0x03);
		Sensor_Write_Register(0xa6, 0xdf);
		Sensor_Write_Register(0xa7, 0xdf);
	}
	else if(ucxUVC_PU_Power_Frequency_Param == 0x01)			//50Hz
	{
//		AutoProperty1Statue |= 0x02;
//		AutoProperty1Statue &= 0xfe;
//		if(AutoProperty2Statue&0x01==0x00)	//auto exposure time, it can anti-flicker at auto
		{
			if(USBSpeed==HighSpeed)	
			{
			/*	if((uixVLength >> 12) == Output_YUV422)			ucI = 0x01;
				else if((uixVLength >> 12) == Output_RAWDATA)	ucI = 0x04; */
				ucI = 0x01;
			}
			else 
			{
				if((uixVLength >> 12) == Output_YUV422)
				{
					if(uixHLength == 640)						                        ucI = 0x07;	
					else if((uixHLength == 320)||(uixHLength == 352))					ucI = 0x0a;	
					else if((uixHLength == 160)||(uixHLength == 176)) 					ucI = 0x0d;	
				}
			/*	else if((uixVLength >> 12) == Output_RAWDATA)
				{
					if(uixHLength == 640)					                        	ucI = 0x10;	
					else if((uixHLength == 320) 					ucI = 0x13;	
					else if((uixHLength == 160) ||(uixHLength == 176))				    ucI = 0x16;	
				} */
			}
		}

		Sensor_Write_Register(0xa1, 0x0b);
		Sensor_Write_Register(0xa6, 0xd8);
		Sensor_Write_Register(0xa7, 0xd8);
	}
	else if(ucxUVC_PU_Power_Frequency_Param == 0x02)			//60Hz
	{
//		AutoProperty1Statue |= 0x02;
//		AutoProperty1Statue |= 0x01;
//		if(AutoProperty2Statue&0x01==0x00)	//auto exposure time, it can anti-flicker at auto
		{
			if(USBSpeed==HighSpeed)	
			{
			/*	if((uixVLength >> 12) == Output_YUV422)			ucI = 0x02;
				else if((uixVLength >> 12) == Output_RAWDATA)	ucI = 0x05; */
				ucI = 0x02;
			}
			else 
			{
				if((uixVLength >> 12) == Output_YUV422)
				{
					if(uixHLength == 640)						        ucI = 0x08;	
					else if((uixHLength == 320)||(uixHLength == 352)) 	ucI = 0x0b;	
					else if((uixHLength == 160)||(uixHLength == 176))   ucI = 0x0e;	
				}
			/*	else if((uixVLength >> 12) == Output_RAWDATA)
				{
					if(uixHLength == 640)						ucI = 0x11;	
					else if(uixHLength == 320) 					ucI = 0x14;	
					else if(uixHLength == 160) 					ucI = 0x17;	
				}*/
			}
		}
		Sensor_Write_Register(0xa1, 0x03);//0x0b);
		Sensor_Write_Register(0xa6, 0xdf);//0xd8);
		Sensor_Write_Register(0xa7, 0xdf);//0xd8);
	}
	Sensor_Write_Register(0x2b, Dummy_Pixel[ucI]);//0x03);			//dummy pixel, 0x2a[7:4]+0x2b
//	Sensor_Write_Register(0x2a, 0x00);//(Sensor_Read_Register(0x2a)&0x0f)|(Dummy_Pixel[ucI]<<4));	
//	Sensor_Write_Register(0x2d, 0x00);//Dummy_Line[ucI+1]);						//dummy line, 0x2e+0x2d
//	Sensor_Write_Register(0x2e, 0x00);//Dummy_Line[ucI]);						
	Sensor_Write_Register(0x9d, Banding_Filter[ucI]);					//50Hz setting value, 0x9d
	Sensor_Write_Register(0x9e, Banding_Filter[ucI]);					//60Hz setting value, 0x9e

	if(ucxUVC_PU_Power_Frequency_Param == 0x00)//outdoor
	{
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf5));
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x02));
		Sensor_Write_Register(0xa5, 0x05);
		Sensor_Write_Register(0xab, 0x07);
	}
	if(ucxUVC_PU_Power_Frequency_Param == 0x01)//50hz
	{
//		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x08));//enable 50/60Hz atuo detection
//		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x02));
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf5));
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x08));
		Sensor_Write_Register(0xa5, 0x02);
		Sensor_Write_Register(0xab, 0x03);
	}
	if(ucxUVC_PU_Power_Frequency_Param == 0x02)//60hz
	{
//		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf7));//disable 50/60Hz atuo detection					//60Hz setting value, 0x9e
//		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x02));
		Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0xf5));
		Sensor_Write_Register(0xa5, 0x05);
		Sensor_Write_Register(0xab, 0x07);
	}
}
#endif

/*
#if 0
void Adjust_7670_ET_50hz(void)
{	
	xdata uchar ImageY;
	static uchar ii = 0;

	if(ii<=8)
	{
		ii++;
		return;
	}
	else
	{
  		ii=0;
	}

	if((ucxUVC_CT_AE_Mode_Param&0x02)==0x02)//auto exposure
	{
		ImageY = Sensor_Read_Register(0x2f);
	
		if(ImageY<40)
		{
			if((Sensor_Read_Register(0x00)>=0x10)&&(nightmode==0))//current status is disable-night-mode
			{			
				Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)|0x80)); // enable night mode
				nightmode = 1;
			}
		}
		else if(ImageY>88)
		{
			if((Sensor_Read_Register(0x00)<=0x14)&&nightmode==1)//current status is enable-light-mode
			{
				Sensor_Write_Register(0x3b, (Sensor_Read_Register(0x3b)&0x7f));	// disable night mode
				Sensor_Write_Register(0x2d, 0x00);	// clear 0x2d,0x2e
				Sensor_Write_Register(0x2e, 0x00);
				nightmode=0;
			}
		}
	}
	return;
}
#endif */

void Set_Sensor_Sharpness(void)					//set sensor sharpness
{
//    xdata uchar ucTemp;
    if(0x20|Sensor_Read_Register(0x41)==0x20)
	{
	  Sensor_Write_Register(0x41, (0xdf&Sensor_Read_Register(0x41)));
	}
//  ucTemp=(Sensor_Read_Register(0x3f)&0xe0);
	Sensor_Write_Register(0x3f, (Sensor_Read_Register(0x3f)&0xe0)|(ucxUVC_PU_Sharpness_Param[0]/4));
//	Sensor_Write_Register(0x41, 0xdf&Sensor_Read_Register(0x41));
//	Sensor_Write_Register(0x3f, (ucxUVC_PU_Sharpness_Param[0]/4)|(Sensor_Read_Register(0x3f)&0xe0));
//	Sensor_Write_Register(0x41, 0xdf&Sensor_Read_Register(0x41));
//	Sensor_Write_Register(0x3f, (ucValue/4)|(Sensor_Read_Register(0x3f)&0xe0));
//	ucxUVC_PU_Sharpness_Param[1] = 0x00;	
}

void Set_Sensor_Brightness(void)
{
//	Sensor_Write_Register(0xa0, (ucValue)*2);	
//	Sensor_Write_Register(0x9f,	((ucValue)*2+0x10));
	if(ucxUVC_PU_Brightness_Param[0]>59)  Sensor_Write_Register(0x55,(ucxUVC_PU_Brightness_Param[0]-59));
	else                                  Sensor_Write_Register(0x55,((59-ucxUVC_PU_Brightness_Param[0])|0x80));
}

uchar code Gamma1[]=      //contrast -2
{
	   0x7a,  0x19, 
       0x7b,  0x3B, 
       0x7c,  0x4B, 
       0x7d,  0x60, 
       0x7e,  0x7B, 
       0x7f,  0x85, 
       0x80,  0x8E, 
       0x81,  0x96, 
       0x82,  0x9D,
       0x83,  0xA3, 
       0x84,  0xA9, 
       0x85,  0xB5, 
       0x86,  0xBF, 
       0x87,  0xD0, 
       0x88,  0xDF, 
       0x89,  0xED, 
};
uchar code Gamma2[]=    //contrast -1
{
	    0x7a,  0x1c,
        0x7b,  0x30,
        0x7c,  0x3F,
        0x7d,  0x54,
        0x7e,  0x6F,
        0x7f,  0x79,
        0x80,  0x82,
        0x81,  0x8B,
        0x82,  0x92,
        0x83,  0x99,
        0x84,  0xA0,
        0x85,  0xAC,
        0x86,  0xB7,
        0x87,  0xCA,
        0x88,  0xDB,
        0x89,  0xEB,
};
uchar code Gamma3[]=	//default 0
{	  
        0x7a, 0x20, 
        0x7b, 0x1c,
        0x7c, 0x28, 
        0x7d, 0x3c, 
        0x7e, 0x5a, 
        0x7f, 0x68, 
        0x80, 0x76, 
        0x81, 0x80, 
        0x82, 0x88,
        0x83, 0x8f, 
        0x84, 0x96, 
        0x85, 0xa3, 
        0x86, 0xaf, 
        0x87, 0xc4, 
        0x88, 0xd7, 
        0x89, 0xe8, 
};
uchar code Gamma4[]=  //contrast 1
{	  
        0x7a,  0x2C, 
        0x7b,  0x11, 
        0x7c,  0x1a, 
        0x7d,  0x2a, 
        0x7e,  0x42, 
        0x7f,  0x4c, 
        0x80,  0x56, 
        0x81,  0x5f, 
        0x82,  0x67, 
        0x83,  0x70, 
        0x84,  0x78, 
        0x85,  0x87, 
        0x86,  0x95, 
        0x87,  0xaf, 
        0x88,  0xc8, 
        0x89,  0xdf, 
};
uchar code Gamma5[]=  //contrast 2
{	   
        0x7a,  0x35,
        0x7b,  0x09, 
        0x7c,  0x0f, 
        0x7d,  0x1b,
        0x7e,  0x30,
        0x7f,  0x39,
        0x80,  0x43,
        0x81,  0x4b,
        0x82,  0x54,
        0x83,  0x5c,
        0x84,  0x64,
        0x85,  0x74,
        0x86,  0x84,
        0x87,  0xa1,
        0x88,  0xbd,
        0x89,  0xd8,
};	
#if 1
///////////////////////////////////////////////////////////////////////
/*
uchar code Gamma6[]=        //contrast1
{	   
		0x7a, 0x20,
		0x7b, 0x1e,
		0x7c, 0x2c,
		0x7d, 0x41,
		0x7e, 0x62,
		0x7f, 0x6f,
		0x80, 0x79,
		0x81, 0x83,
		0x82, 0x8b,
		0x83, 0x92,
		0x84, 0x9a,
		0x85, 0xa8,
		0x86, 0xb2,
		0x87, 0xc4,
		0x88, 0xd7,
		0x89, 0xe8,
}; */

uchar code Gamma6[]=     //contrast3
{	   
		0x7a, 0x39,
		0x7b, 0x05,
		0x7c, 0x0b,
		0x7d, 0x15,
		0x7e, 0x2a,
		0x7f, 0x34,
		0x80, 0x3d,
		0x81, 0x47,
		0x82, 0x4f,
		0x83, 0x58,
		0x84, 0x5e,
		0x85, 0x6f,
		0x86, 0x7e,
		0x87, 0x9d,
		0x88, 0xba,
		0x89, 0xd5,
};
uchar code Gamma7[]=   //contrast4
{	   
		0x7a, 0x3e,
		0x7b, 0x03,
		0x7c, 0x07,
		0x7d, 0x0f,
		0x7e, 0x1f,
		0x7f, 0x27,
		0x80, 0x30,
		0x81, 0x38,
		0x82, 0x42,
		0x83, 0x4a,
		0x84, 0x51,
		0x85, 0x62,
		0x86, 0x71,
		0x87, 0x93,
		0x88, 0xb3,
		0x89, 0xd1,
};

uchar code Gamma8[]=     //contrast 5
{	   
		0x7a, 0x4e,
		0x7b, 0x03,
		0x7c, 0x07,
		0x7d, 0x0c,
		0x7e, 0x15,
		0x7f, 0x1a,
		0x80, 0x21,
		0x81, 0x26,
		0x82, 0x2e,
		0x83, 0x33,
		0x84, 0x38,
		0x85, 0x47,
		0x86, 0x54,
		0x87, 0x72,
		0x88, 0x9c,
		0x89, 0xc5,
};
#endif
///////////////////////////////////////////////////////////////////////////	
void Set_Sensor_Contrast()
{
 	Sensor_Write_Register(0x56,(ucxUVC_PU_Contrast_Param[0]+0x14));    												
}

void Set_Sensor_Gamma()
{
//   if(ucxUVC_PU_Gamma_Param[0]==9)		    SensorRGF_Set_Loop(sizeof(Gamma9)/2,Gamma9);
 /* else*/if(ucxUVC_PU_Gamma_Param[0]==8)   SensorRGF_Set_Loop(sizeof(Gamma8)/2,Gamma8);
	else if(ucxUVC_PU_Gamma_Param[0]==7)	SensorRGF_Set_Loop(sizeof(Gamma7)/2,Gamma7);
	else if(ucxUVC_PU_Gamma_Param[0]==6)	SensorRGF_Set_Loop(sizeof(Gamma6)/2,Gamma6);
	else if(ucxUVC_PU_Gamma_Param[0]==5)	SensorRGF_Set_Loop(sizeof(Gamma5)/2,Gamma5);
	else if(ucxUVC_PU_Gamma_Param[0]==4)	SensorRGF_Set_Loop(sizeof(Gamma4)/2,Gamma4);
	else if(ucxUVC_PU_Gamma_Param[0]==3)	SensorRGF_Set_Loop(sizeof(Gamma3)/2,Gamma3);
	else if(ucxUVC_PU_Gamma_Param[0]==2)	SensorRGF_Set_Loop(sizeof(Gamma2)/2,Gamma2);
	else if(ucxUVC_PU_Gamma_Param[0]==1)	SensorRGF_Set_Loop(sizeof(Gamma1)/2,Gamma1);
}

uchar code Saturation0[]=
{ 
	0x4f, 0x40,    
	0x50, 0x40,   
	0x51, 0x00,   
	0x52, 0x11,   
	0x53, 0x2f,   
	0x54, 0x40,   
	0x58, 0x9e,   
};
uchar code Saturation1[]=
{
	0x4f, 0x66,   
	0x50, 0x66,   
	0x51, 0x00,   
	0x52, 0x1b,   
	0x53, 0x4b,   
	0x54, 0x66,   
	0x58, 0x9e,
};
uchar code Saturation2[]=
{

	0x4f, 0x80, 
	0x50, 0x80, 
	0x51, 0x00,   
	0x52, 0x22, 
	0x53, 0x5e, 
	0x54, 0x80, 
	0x58, 0x9e,
};
uchar code Saturation3[]=
{
	0x4f, 0x99,   
	0x50, 0x99, 
	0x51, 0x00,   
	0x52, 0x28,   
	0x53, 0x70,   
	0x54, 0x99,   
	0x58, 0x9e,   
};
uchar code Saturation4[]=
{
	0x4f, 0xc0,    
	0x50, 0xc0,   
	0x51, 0x00, 
	0x52, 0x33, 
	0x53, 0x8d,  
	0x54, 0xc0,   
	0x58, 0x9e,  
};

void Set_Sensor_Saturation(void)					//set sensor saturation
{
    if (ucxUVC_PU_Saturation_Param[0]==0)
	{
 		SensorRGF_Set_Loop(sizeof(Saturation0)/2,Saturation0);
  	}
	else if (ucxUVC_PU_Saturation_Param[0]==1)
	{
	    SensorRGF_Set_Loop(sizeof(Saturation1)/2,Saturation1);
	}
	else if (ucxUVC_PU_Saturation_Param[0]==2)
	{
	    SensorRGF_Set_Loop(sizeof(Saturation2)/2,Saturation2);	
	}
	else if (ucxUVC_PU_Saturation_Param[0]==3)
	{
	   SensorRGF_Set_Loop(sizeof(Saturation3)/2,Saturation3);	
	}
	else if (ucxUVC_PU_Saturation_Param[0]==4)
	{
	    SensorRGF_Set_Loop(sizeof(Saturation4)/2,Saturation4);	
	}  		
}

/*
//////////////////////////////////////////////////////////////////////////////////////////////
//	code uchar CosSin[]=
//	{
//	//	0   5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90
//	    0, 11, 22, 33, 44, 54, 64, 73, 82, 91, 98,105,111,116,120,124,126,127,128,
//	};
	code uchar CosSin[]=
	{
	//	0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
	    0,  2,  4,  7,  9, 11, 13, 16, 18, 20, 22, 24, 27, 29, 31, 33, 35, 37, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 73, 75, 77, 79, 81, 82, 84, 86, 87, 89, 91, 92, 94, 95, 97, 98, 99,101,102,104,105,106,107,109,110,111,112,113,114,115,116,117,118,119,119,120,121,122,122,123,124,124,125,125,126,126,126,127,127,127,128,128,128,128,128,128,
	};
//	0x4f, 0x80, 
//	0x50, 0x80, 
//	0x51, 0x00,   
//	0x52, 0x22, 
//	0x53, 0x5e, 
//	0x54, 0x80, 
//	0x58, 0x9e,
#define	M1	(0x0080)	//(+0x80)	//aveo default
#define	M2	(0xFF80)	//(-0x80)
#define	M3	(0x0000)	//(-0x00)
#define	M4	(0xFFDE)	//(-0x22)
#define	M5	(0xFFA2)	//(-0x5E)
#define	M6	(0x0080)	//(+0x80)
xdata uchar Buffer[16] _at_ 0x9c00;
xdata uint BufferM[16] _at_ 0x9c10;

#if 1
int Multi(int value1,int value2)// reentrant
{
	return((int)(value1*value2/64));
}
#endif
void Set_Sensor_Matrix(void) reentrant					//set sensor hue
{
	int i128XCos,i128XSin;
	int iTemp;
	uchar ucTemp;

	ucTemp=ucxUVC_PU_Hue_Manual_Param[0];
	if(ucxUVC_PU_Hue_Manual_Param[1]&0x80)	{i128XSin=-1;ucTemp=256-ucTemp;}
	else									{i128XSin=+1;}
	if(ucTemp>90)	{i128XCos=-1;ucTemp=180-ucTemp;}
	else			{i128XCos=+1;}
	i128XCos=i128XCos*CosSin[(90-ucTemp)];
	i128XSin=i128XSin*CosSin[ucTemp];
	ucTemp=(uchar)((uint)ucxUVC_PU_Saturation_Param[0]*64/25);
	i128XCos=i128XCos*ucTemp/128;
	i128XSin=i128XSin*ucTemp/128;

	ucTemp=0;
	iTemp=Multi(((int)M4),i128XSin)+Multi(((int)M1),i128XCos);	if(iTemp<0){ucTemp|=0x01;iTemp=-iTemp;}BufferM[1]=(uint)iTemp;
	iTemp=Multi(((int)M5),i128XSin)+Multi(((int)M2),i128XCos);	if(iTemp<0){ucTemp|=0x02;iTemp=-iTemp;}BufferM[2]=(uint)iTemp;
	iTemp=Multi(((int)M6),i128XSin)+Multi(((int)M3),i128XCos);	if(iTemp<0){ucTemp|=0x04;iTemp=-iTemp;}BufferM[3]=(uint)iTemp;
	iTemp=Multi(((int)M4),i128XCos)-Multi(((int)M1),i128XSin);	if(iTemp<0){ucTemp|=0x08;iTemp=-iTemp;}BufferM[4]=(uint)iTemp;
	iTemp=Multi(((int)M5),i128XCos)-Multi(((int)M2),i128XSin);
	if(iTemp<0){ucTemp|=0x10;iTemp=-iTemp;}BufferM[5]=(uint)iTemp;
	iTemp=Multi(((int)M6),i128XCos)-Multi(((int)M3),i128XSin);	if(iTemp<0){ucTemp|=0x20;iTemp=-iTemp;}BufferM[6]=(uint)iTemp;
	Buffer[0]=ucTemp;
	for(ucTemp=1;ucTemp<7;ucTemp++)	if(BufferM[ucTemp]>255)break;
	if(ucTemp<7){for(ucTemp=1;ucTemp<7;ucTemp++)Buffer[ucTemp]=BufferM[ucTemp]/2;Sensor_Write_Register(0x41,Sensor_Read_Register(0x41)|0x02);}
	else		{for(ucTemp=1;ucTemp<7;ucTemp++)Buffer[ucTemp]=BufferM[ucTemp];Sensor_Write_Register(0x41,Sensor_Read_Register(0x41)&0xFD);}
	for(ucTemp=1;ucTemp<7;ucTemp++)Sensor_Write_Register(0x4e+ucTemp,Buffer[ucTemp]);
//	Sensor_Write_Register(0x4f,Buffer[1]);
//	Sensor_Write_Register(0x50,Buffer[2]);
//	Sensor_Write_Register(0x51,Buffer[3]);
//	Sensor_Write_Register(0x52,Buffer[4]);
//	Sensor_Write_Register(0x53,Buffer[5]);
//	Sensor_Write_Register(0x54,Buffer[6]);
	Sensor_Write_Register(0x58,Buffer[0]); 
}

//end of hue
//////////////////////////////////////////////////////////////////////////////////////////////

void Set_Sensor_Saturation()
{
 	 Set_Sensor_Matrix();  												
}

void Set_Sensor_Hue()
{
  	 Set_Sensor_Matrix();											
} */


void Set_Sensor_Default_Property(void)
{
	Set_Sensor_LightEnvironment();	//50Hz

	Set_Sensor_Brightness();
	Set_Sensor_Sharpness();
	Set_Sensor_Saturation();
    Set_Sensor_Contrast();   
    Set_Sensor_Gamma();
 // Set_Sensor_Hue();
}

